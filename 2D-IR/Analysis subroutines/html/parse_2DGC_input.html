
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>parse_2DGC_input</title><meta name="generator" content="MATLAB 9.6"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2019-04-18"><meta name="DC.source" content="parse_2DGC_input.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#3">Process the input structure</a></li><li><a href="#4">Initialize the variables</a></li><li><a href="#5">Define the fit parameter positions (indexes) of the globally-fit parameters</a></li><li><a href="#6">THIS NEEDS TO BE FIXED PROPERLY FOR INTRAMOLECULAR CROSS PEAKS. PENDING</a></li><li><a href="#7">Define the fit parameter positions (indexes) of the amplitudes and correlation coefficients</a></li><li><a href="#8">If it's a diagonal peak,</a></li><li><a href="#9">If it's not a diagonal peak, X0 and Y0 are given by the corresponding diagonal peaks.</a></li><li><a href="#10">BUILD THE FIT FUNCTION, STARTING PARAMETERS AND BOUNDS</a></li><li><a href="#11">Diagonal peaks</a></li><li><a href="#12">Cross peaks</a></li><li><a href="#13">Time-dependent parameters</a></li><li><a href="#14">SAVE the positions of the parameters to the ParamPos structure</a></li></ul></div><pre class="codeinput"><span class="keyword">function</span> [PeaksFunction,Start_param,UB,LB,ParamPos] = parse_2DGC_input(fitparameters,Ndelays,varargin)
</pre><pre class="codeinput"><span class="comment">% Description: This function parses the fitparameters structure into a</span>
<span class="comment">% vector of starting parameters, upper bounds and lower bounds, together</span>
<span class="comment">% with the function to be used in the fit</span>
</pre><h2 id="3">Process the input structure</h2><pre class="codeinput"><span class="comment">% Hardcoded settings</span>
equal_SxSy  = 1;

<span class="keyword">if</span> isempty(varargin)
    Omega   = {linspace(1900,2200,100);linspace(1900,2200,32)};
    ZData   = ones(length(Omega{1}),length(Omega{2}),Ndelays);
<span class="keyword">else</span>
    Omega   = varargin{1};
    ZData   = varargin{2};
<span class="keyword">end</span>

<span class="comment">% Get the number of peaks (number of columns of the table) and sort them</span>
<span class="comment">% into Diagonal and Cross-peaks</span>
Npeaks      = size(fitparameters,2);
isDiagonal  = contains(fitparameters(end,:),<span class="string">'Diag'</span>);

<span class="comment">% Get the W1 and W3 axes</span>
PumpAxis    = Omega{1};
ProbeAxis   = Omega{2};

<span class="comment">% Get the starting parameters (as a cell)</span>
X0_start    = cellfun(@str2num,fitparameters(1,:),<span class="string">'un'</span>,0); <span class="comment">% Position along W1</span>
Y0_start    = cellfun(@str2num,fitparameters(2,:),<span class="string">'un'</span>,0); <span class="comment">% Anharmonicity/Position along W3 (see below)</span>
SX_start    = cellfun(@str2num,fitparameters(3,:),<span class="string">'un'</span>,0); <span class="comment">% Sigma_x</span>
SY_start    = cellfun(@str2num,fitparameters(4,:),<span class="string">'un'</span>,0); <span class="comment">% Sigma_y</span>

<span class="comment">% Convert the cells to double arrays</span>
X0_start    = [X0_start{:}]';
Y0_start    = [Y0_start{:}]';
SX_start    = [SX_start{:}]';
SY_start    = [SY_start{:}]';
C_start     = fitparameters(5,:)';

<span class="comment">% % The anharmonicities are smaller than 100 cm^-1. If a number &gt;100 cm^-1 is</span>
<span class="comment">% % entered, then the user didn't mean anhmarmonicity but absolute position</span>
<span class="comment">% % of the peak along W3. This is stored in the vector "isW3Pos"</span>
<span class="comment">% isW3Pos     = abs(Y0_start)&lt;=100;</span>
</pre><pre class="codeoutput error">Not enough input arguments.

Error in parse_2DGC_input (line 13)
    ZData   = ones(length(Omega{1}),length(Omega{2}),Ndelays);
</pre><h2 id="4">Initialize the variables</h2><pre class="codeinput">x0_pos      = zeros(Npeaks,1);
y0_pos      = zeros(Npeaks,1);
Sx_pos      = zeros(Npeaks,1);
Sy_pos      = zeros(Npeaks,1);
GSBamp_pos  = zeros(Ndelays,Npeaks);
ESAamp_pos  = zeros(Ndelays,Npeaks);
C_pos       = zeros(Ndelays,Npeaks);
DiagPkXID   = zeros(Npeaks,1);
DiagPkYID   = zeros(Npeaks,1);
pump_pos    = zeros(Npeaks,1);
probe_pos   = zeros(Npeaks,2); <span class="comment">% Probe positions are stored in the form (GSB,ESA)</span>
probe_idx   = zeros(Npeaks,2);
</pre><h2 id="5">Define the fit parameter positions (indexes) of the globally-fit parameters</h2><pre class="codeinput">tot_idx     = 0;
<span class="keyword">for</span> m=1:Npeaks
    <span class="keyword">if</span> isDiagonal(m)
        <span class="comment">% Define the parameter positions: all diagonal peak parameters are fitted</span>
        x0_pos(m)   = tot_idx+1; tot_idx = tot_idx+1;
        y0_pos(m)   = tot_idx+1; tot_idx = tot_idx+1;
        Sx_pos(m)   = tot_idx+1; tot_idx = tot_idx+1;
        <span class="keyword">if</span> equal_SxSy == 1
            Sy_pos(m)   = Sx_pos(m);
        <span class="keyword">else</span>
            Sy_pos(m)   = tot_idx+1; tot_idx = tot_idx+1;
        <span class="keyword">end</span>
        <span class="comment">% Get the starting peak positions (in cm-1) to find later the starting amplitudes</span>
        pump_pos(m)     = X0_start(m);              <span class="comment">% W1 position</span>
        probe_pos(m,1)  = X0_start(m);              <span class="comment">% W3 position (GSB)</span>
        probe_pos(m,2)  = X0_start(m)-Y0_start(m);  <span class="comment">% W3 position (ESA)</span>
    <span class="keyword">else</span> <span class="comment">% If it's not a diagonal peak, X0 and Y0 are given by the corresponding diagonal peaks.</span>
</pre><h2 id="6">THIS NEEDS TO BE FIXED PROPERLY FOR INTRAMOLECULAR CROSS PEAKS. PENDING</h2><p>Find the diagonal peak with the closest position</p><pre class="codeinput">        DiagX               = X0_start;
        DiagX(~isDiagonal)  = NaN;
        DiagPkXID(m)        = findClosestId2Val(DiagX,X0_start(m));
        x0_pos(m)           = x0_pos(DiagPkXID(m));
        <span class="comment">% The Y position can be either linked to the diagonal peak or another fit parameter</span>
        <span class="keyword">if</span> Y0_start(m) &lt; 0
            DiagPkYID(m)        = findClosestId2Val(DiagX,abs(Y0_start(m)));
            y0_pos(m)           = y0_pos(DiagPkYID(m));
            <span class="comment">% Get the starting peak positions (in cm-1) to find later the starting amplitudes</span>
            pump_pos(m)     = X0_start(DiagPkXID(m));                           <span class="comment">% W1 position</span>
            probe_pos(m,1)  = X0_start(DiagPkYID(m));                           <span class="comment">% W3 position (GSB)</span>
            probe_pos(m,2)  = X0_start(DiagPkYID(m))-Y0_start(DiagPkYID(m));    <span class="comment">% W3 position (ESA)</span>
        <span class="keyword">else</span>
            y0_pos(m) = tot_idx+1; tot_idx = tot_idx+1;
            <span class="comment">% Get the starting peak positions (in cm-1) to find later the starting amplitudes</span>
            pump_pos(m)     = X0_start(DiagPkXID(m));                           <span class="comment">% W1 position</span>
            probe_pos(m,1)  = X0_start(DiagPkYID(m));                           <span class="comment">% W3 position (GSB)</span>
            probe_pos(m,2)  = X0_start(DiagPkYID(m))-Y0_start(DiagPkYID(m));    <span class="comment">% W3 position (ESA)</span>
        <span class="keyword">end</span>
        Sx_pos(m)           = Sx_pos(DiagPkXID(m));
        Sy_pos(m)           = Sy_pos(DiagPkYID(m));

    <span class="keyword">end</span>

<span class="keyword">end</span>
</pre><h2 id="7">Define the fit parameter positions (indexes) of the amplitudes and correlation coefficients</h2><pre class="codeinput">tot_idx     = max([x0_pos;y0_pos;Sx_pos;Sy_pos]);
peakfnc     = cell(Npeaks,1);

<span class="keyword">for</span> m=1:Npeaks
    <span class="keyword">if</span> isDiagonal(m)
</pre><h2 id="8">If it's a diagonal peak,</h2><pre class="codeinput">        <span class="keyword">for</span> n=1:Ndelays
            GSBamp_pos(n,m) = tot_idx+1; tot_idx = tot_idx+1;
            ESAamp_pos(n,m) = tot_idx+1; tot_idx = tot_idx+1;
            C_pos(n,m)      = tot_idx+1; tot_idx = tot_idx+1;
        <span class="keyword">end</span>
    <span class="keyword">else</span>
</pre><h2 id="9">If it's not a diagonal peak, X0 and Y0 are given by the corresponding diagonal peaks.</h2><p>Find the diagonal peak with the closest position</p><pre class="codeinput">        DiagX               = X0_start;
        DiagX(~isDiagonal)  = NaN;
        DiagPkXID(m)        = findClosestId2Val(DiagX,X0_start(m));
        DiagPkYID(m)        = findClosestId2Val(DiagX,abs(Y0_start(m)));

        <span class="comment">% The positions along W1, Sx and Sy are given by the diagonal peaks</span>
        x0_pos(m) = x0_pos(DiagPkXID(m));
        Sx_pos(m) = Sx_pos(DiagPkXID(m));
        Sy_pos(m) = Sy_pos(DiagPkYID(m));

        <span class="comment">% If the starting anharmonicity is &lt;0, then link to that of the diagonal peak,</span>
        <span class="comment">% otherwise it's a fit parameter</span>
        <span class="keyword">if</span> Y0_start(m) &lt; 0
            y0_pos(m)   = y0_pos(DiagPkYID(m));
        <span class="keyword">else</span>
            y0_pos(m)   = tot_idx+1; tot_idx = tot_idx+1;
        <span class="keyword">end</span>

        <span class="comment">% The amplitudes are independent for each peak</span>
        <span class="keyword">for</span> n=1:Ndelays
            GSBamp_pos(n,m) = tot_idx+1; tot_idx = tot_idx+1;
            ESAamp_pos(n,m) = tot_idx+1; tot_idx = tot_idx+1;
        <span class="keyword">end</span>

        <span class="comment">% The correlation is either identically zero or another fit parameter</span>
        <span class="keyword">if</span> ~contains(C_start{m},<span class="string">'0h'</span>,<span class="string">'IgnoreCase'</span>,true)
            <span class="keyword">for</span> n=1:Ndelays
                C_pos(n,m)  = tot_idx+1; tot_idx = tot_idx+1;
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="comment">% Build the peak function strings</span>
    x0str   = num2str(x0_pos(m));
    y0str   = num2str(y0_pos(m));
    sxstr   = num2str(Sx_pos(m));
    systr   = num2str(Sy_pos(m));
    peakID  = num2str(m);
    peakGSB = num2str(2.*m-1);
    peakESA = num2str(2.*m);
    <span class="keyword">switch</span> isDiagonal(m)
        <span class="keyword">case</span> 1
            peakfnc{m} = [<span class="string">'G2Dc(X,Y,P('</span> x0str <span class="string">'),P('</span> x0str <span class="string">'),P('</span> sxstr <span class="string">'),P('</span> systr <span class="string">'),C{'</span> peakID <span class="string">'},A{'</span> peakGSB <span class="string">'}) + G2Dc(X,Y,P('</span> x0str <span class="string">'),P('</span> x0str <span class="string">')-P('</span> y0str <span class="string">'),P('</span> sxstr <span class="string">'),P('</span> systr <span class="string">'),C{'</span> peakID <span class="string">'},A{'</span> peakESA <span class="string">'})'</span>];
        <span class="keyword">case</span> 0
            <span class="comment">% Check if the correlation coefficient of the cross peaks is a fit parameter or if it's set to zero</span>
            <span class="keyword">if</span> sum(C_pos(:,m),1) == 0
                Cstring = <span class="string">'0'</span>;
            <span class="keyword">else</span>
                Cstring = [<span class="string">'C{'</span> peakID <span class="string">'}'</span>];
            <span class="keyword">end</span>
            <span class="comment">% The position along W1 is given by the diagonal peak</span>
            XpeakGSB_w1 = [<span class="string">'P('</span> num2str(x0_pos(DiagPkXID(m))) <span class="string">')'</span>];

            <span class="comment">% Check if the anharmonicity is the same as the diagonal peak or if it's a fit parameter</span>
            XpeakGSB_w3_str = [<span class="string">'P('</span> num2str(x0_pos(DiagPkYID(m))) <span class="string">')'</span>]; <span class="comment">% GSB of the cross peak between A and B is at (x_A,y_B)</span>
            XpeakESA_w3_str = [XpeakGSB_w3_str <span class="string">'-P('</span> num2str(y0_pos(DiagPkYID(m))) <span class="string">')'</span>];

            <span class="comment">% Write the function string</span>
            peakfnc{m} = [<span class="string">'G2Dc(X,Y,'</span> XpeakGSB_w1 <span class="string">','</span>  XpeakGSB_w3_str <span class="string">',P('</span> sxstr <span class="string">'),P('</span> systr <span class="string">'),'</span> Cstring <span class="string">',A{'</span> peakGSB <span class="string">'}) + G2Dc(X,Y,'</span> XpeakGSB_w1 <span class="string">','</span> XpeakESA_w3_str <span class="string">',P('</span> sxstr <span class="string">'),P('</span> systr <span class="string">'),'</span> Cstring <span class="string">',A{'</span> peakESA <span class="string">'})'</span>];
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><h2 id="10">BUILD THE FIT FUNCTION, STARTING PARAMETERS AND BOUNDS</h2><p>Build the fit function string</p><pre class="codeinput">PeaksFunction     = str2func([<span class="string">'@(P,X,Y,C,A)'</span> strjoin(peakfnc,<span class="string">' + '</span>)]);

<span class="comment">% Build the vector of starting parameters</span>
Start_param     = zeros(tot_idx,1);
UB              = zeros(tot_idx,1); <span class="comment">% Upper bounds</span>
LB              = zeros(tot_idx,1); <span class="comment">% Lower bounds</span>
</pre><h2 id="11">Diagonal peaks</h2><p>Time-independent parameters</p><pre class="codeinput">Start_param(x0_pos(isDiagonal)) = X0_start(isDiagonal);
Start_param(y0_pos(isDiagonal)) = Y0_start(isDiagonal);
Start_param(Sx_pos(isDiagonal)) = SX_start(isDiagonal);
Start_param(Sy_pos(isDiagonal)) = SY_start(isDiagonal);

UB(x0_pos(isDiagonal)) = X0_start(isDiagonal)+10;
UB(y0_pos(isDiagonal)) = 50;
UB(Sx_pos(isDiagonal)) = 50;
UB(Sy_pos(isDiagonal)) = 50;

LB(x0_pos(isDiagonal)) = X0_start(isDiagonal)-10;
LB(y0_pos(isDiagonal)) = 5;
LB(Sx_pos(isDiagonal)) = 5;
LB(Sy_pos(isDiagonal)) = 5;
</pre><h2 id="12">Cross peaks</h2><pre class="codeinput"><span class="comment">%%%%% PENDING: Explicit definition for intramolecular cross peaks</span>
</pre><h2 id="13">Time-dependent parameters</h2><p>Spectral diffusion</p><pre class="codeinput">Start_param(C_pos(C_pos~=0)) = 0.4;     <span class="comment">% Starting C value of 0.5 for all points. Needs improvement.</span>
UB(C_pos(C_pos~=0))     = 0.99;         <span class="comment">% C can only be in the range [-1 1]. Considering 0 to 1 only</span>
LB(C_pos(C_pos~=0))     = 0;            <span class="comment">% C can only be in the range [-1 1]. Considering 0 to 1 only</span>


<span class="comment">% Amplitudes</span>
<span class="comment">% The data is normalized, so the min/max amplitudes should be around +- 5</span>
    <span class="comment">% Get the positions of each peak in terms of the W1 and W3 axes of the dataset</span>
    pump_idx        = findClosestId2Val(PumpAxis,pump_pos)';
    probe_idx(:,1)  = findClosestId2Val(ProbeAxis,probe_pos(:,1));
    probe_idx(:,2)  = findClosestId2Val(ProbeAxis,probe_pos(:,2));

    <span class="comment">% Evaluate the amplitudes of the input data at the position of each peak and use them as initial</span>
    <span class="comment">% parameters for the fit</span>
    <span class="keyword">for</span> m=1:Npeaks
        Start_param(GSBamp_pos(:,m))  = squeeze(ZData(pump_idx(m),probe_idx(m,1),:)); <span class="comment">% GSB</span>
        Start_param(ESAamp_pos(:,m))  = squeeze(ZData(pump_idx(m),probe_idx(m,2),:))'; <span class="comment">% ESA</span>
    <span class="keyword">end</span>

UB(GSBamp_pos(:))       = 0;            <span class="comment">% Bleaches can only be negative</span>
UB(ESAamp_pos(:))       = +5;           <span class="comment">% ESA can only be positive</span>

LB(GSBamp_pos(:))       = -5;           <span class="comment">% Bleaches can only be negative</span>
LB(ESAamp_pos(:))       = 0;            <span class="comment">% ESA can only be positive</span>
</pre><h2 id="14">SAVE the positions of the parameters to the ParamPos structure</h2><pre class="codeinput">ParamPos.Npeaks     = Npeaks;
ParamPos.Ndelays    = Ndelays;
ParamPos.x0_pos     = x0_pos;
ParamPos.y0_pos     = y0_pos;
ParamPos.Sx_pos     = Sx_pos;
ParamPos.Sy_pos     = Sy_pos;
ParamPos.GSBamp_pos = GSBamp_pos;
ParamPos.ESAamp_pos = ESAamp_pos;
ParamPos.isDiagonal = isDiagonal;
ParamPos.C_pos      = C_pos;
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2019a</a><br></p></div><!--
##### SOURCE BEGIN #####
function [PeaksFunction,Start_param,UB,LB,ParamPos] = parse_2DGC_input(fitparameters,Ndelays,varargin)
% Description: This function parses the fitparameters structure into a
% vector of starting parameters, upper bounds and lower bounds, together
% with the function to be used in the fit

%% Process the input structure

% Hardcoded settings
equal_SxSy  = 1;

if isempty(varargin)
    Omega   = {linspace(1900,2200,100);linspace(1900,2200,32)};
    ZData   = ones(length(Omega{1}),length(Omega{2}),Ndelays);
else
    Omega   = varargin{1};
    ZData   = varargin{2};
end

% Get the number of peaks (number of columns of the table) and sort them
% into Diagonal and Cross-peaks
Npeaks      = size(fitparameters,2);
isDiagonal  = contains(fitparameters(end,:),'Diag');

% Get the W1 and W3 axes
PumpAxis    = Omega{1};
ProbeAxis   = Omega{2};

% Get the starting parameters (as a cell)
X0_start    = cellfun(@str2num,fitparameters(1,:),'un',0); % Position along W1
Y0_start    = cellfun(@str2num,fitparameters(2,:),'un',0); % Anharmonicity/Position along W3 (see below)
SX_start    = cellfun(@str2num,fitparameters(3,:),'un',0); % Sigma_x
SY_start    = cellfun(@str2num,fitparameters(4,:),'un',0); % Sigma_y

% Convert the cells to double arrays
X0_start    = [X0_start{:}]';
Y0_start    = [Y0_start{:}]';
SX_start    = [SX_start{:}]';
SY_start    = [SY_start{:}]';
C_start     = fitparameters(5,:)';

% % The anharmonicities are smaller than 100 cm^-1. If a number >100 cm^-1 is
% % entered, then the user didn't mean anhmarmonicity but absolute position
% % of the peak along W3. This is stored in the vector "isW3Pos"
% isW3Pos     = abs(Y0_start)<=100;

%% Initialize the variables
x0_pos      = zeros(Npeaks,1);
y0_pos      = zeros(Npeaks,1);
Sx_pos      = zeros(Npeaks,1);
Sy_pos      = zeros(Npeaks,1);
GSBamp_pos  = zeros(Ndelays,Npeaks);
ESAamp_pos  = zeros(Ndelays,Npeaks);
C_pos       = zeros(Ndelays,Npeaks);
DiagPkXID   = zeros(Npeaks,1);
DiagPkYID   = zeros(Npeaks,1);
pump_pos    = zeros(Npeaks,1); 
probe_pos   = zeros(Npeaks,2); % Probe positions are stored in the form (GSB,ESA)
probe_idx   = zeros(Npeaks,2);

%% Define the fit parameter positions (indexes) of the globally-fit parameters
tot_idx     = 0;
for m=1:Npeaks
    if isDiagonal(m)
        % Define the parameter positions: all diagonal peak parameters are fitted
        x0_pos(m)   = tot_idx+1; tot_idx = tot_idx+1;
        y0_pos(m)   = tot_idx+1; tot_idx = tot_idx+1;
        Sx_pos(m)   = tot_idx+1; tot_idx = tot_idx+1;
        if equal_SxSy == 1
            Sy_pos(m)   = Sx_pos(m);
        else
            Sy_pos(m)   = tot_idx+1; tot_idx = tot_idx+1;
        end
        % Get the starting peak positions (in cm-1) to find later the starting amplitudes
        pump_pos(m)     = X0_start(m);              % W1 position
        probe_pos(m,1)  = X0_start(m);              % W3 position (GSB)
        probe_pos(m,2)  = X0_start(m)-Y0_start(m);  % W3 position (ESA)
    else % If it's not a diagonal peak, X0 and Y0 are given by the corresponding diagonal peaks.
        %%% THIS NEEDS TO BE FIXED PROPERLY FOR INTRAMOLECULAR CROSS PEAKS. PENDING
        % Find the diagonal peak with the closest position
        DiagX               = X0_start;
        DiagX(~isDiagonal)  = NaN;
        DiagPkXID(m)        = findClosestId2Val(DiagX,X0_start(m));
        x0_pos(m)           = x0_pos(DiagPkXID(m));
        % The Y position can be either linked to the diagonal peak or another fit parameter
        if Y0_start(m) < 0
            DiagPkYID(m)        = findClosestId2Val(DiagX,abs(Y0_start(m)));
            y0_pos(m)           = y0_pos(DiagPkYID(m));
            % Get the starting peak positions (in cm-1) to find later the starting amplitudes
            pump_pos(m)     = X0_start(DiagPkXID(m));                           % W1 position
            probe_pos(m,1)  = X0_start(DiagPkYID(m));                           % W3 position (GSB)
            probe_pos(m,2)  = X0_start(DiagPkYID(m))-Y0_start(DiagPkYID(m));    % W3 position (ESA)
        else 
            y0_pos(m) = tot_idx+1; tot_idx = tot_idx+1;
            % Get the starting peak positions (in cm-1) to find later the starting amplitudes
            pump_pos(m)     = X0_start(DiagPkXID(m));                           % W1 position
            probe_pos(m,1)  = X0_start(DiagPkYID(m));                           % W3 position (GSB)
            probe_pos(m,2)  = X0_start(DiagPkYID(m))-Y0_start(DiagPkYID(m));    % W3 position (ESA)
        end
        Sx_pos(m)           = Sx_pos(DiagPkXID(m));
        Sy_pos(m)           = Sy_pos(DiagPkYID(m));

    end
    
end

%% Define the fit parameter positions (indexes) of the amplitudes and correlation coefficients
tot_idx     = max([x0_pos;y0_pos;Sx_pos;Sy_pos]);
peakfnc     = cell(Npeaks,1);

for m=1:Npeaks
    if isDiagonal(m)
        %%% If it's a diagonal peak, 
        for n=1:Ndelays
            GSBamp_pos(n,m) = tot_idx+1; tot_idx = tot_idx+1;
            ESAamp_pos(n,m) = tot_idx+1; tot_idx = tot_idx+1;
            C_pos(n,m)      = tot_idx+1; tot_idx = tot_idx+1;
        end
    else
        %%% If it's not a diagonal peak, X0 and Y0 are given by the corresponding diagonal peaks.
        % Find the diagonal peak with the closest position
        DiagX               = X0_start;
        DiagX(~isDiagonal)  = NaN;
        DiagPkXID(m)        = findClosestId2Val(DiagX,X0_start(m));
        DiagPkYID(m)        = findClosestId2Val(DiagX,abs(Y0_start(m)));
        
        % The positions along W1, Sx and Sy are given by the diagonal peaks
        x0_pos(m) = x0_pos(DiagPkXID(m));
        Sx_pos(m) = Sx_pos(DiagPkXID(m));
        Sy_pos(m) = Sy_pos(DiagPkYID(m));
        
        % If the starting anharmonicity is <0, then link to that of the diagonal peak,
        % otherwise it's a fit parameter
        if Y0_start(m) < 0
            y0_pos(m)   = y0_pos(DiagPkYID(m));
        else
            y0_pos(m)   = tot_idx+1; tot_idx = tot_idx+1;
        end
        
        % The amplitudes are independent for each peak
        for n=1:Ndelays
            GSBamp_pos(n,m) = tot_idx+1; tot_idx = tot_idx+1;
            ESAamp_pos(n,m) = tot_idx+1; tot_idx = tot_idx+1;
        end
        
        % The correlation is either identically zero or another fit parameter
        if ~contains(C_start{m},'0h','IgnoreCase',true)
            for n=1:Ndelays
                C_pos(n,m)  = tot_idx+1; tot_idx = tot_idx+1;
            end
        end
    end
    
    % Build the peak function strings
    x0str   = num2str(x0_pos(m));
    y0str   = num2str(y0_pos(m));
    sxstr   = num2str(Sx_pos(m));
    systr   = num2str(Sy_pos(m));
    peakID  = num2str(m);
    peakGSB = num2str(2.*m-1);
    peakESA = num2str(2.*m);
    switch isDiagonal(m)
        case 1            
            peakfnc{m} = ['G2Dc(X,Y,P(' x0str '),P(' x0str '),P(' sxstr '),P(' systr '),C{' peakID '},A{' peakGSB '}) + G2Dc(X,Y,P(' x0str '),P(' x0str ')-P(' y0str '),P(' sxstr '),P(' systr '),C{' peakID '},A{' peakESA '})'];
        case 0
            % Check if the correlation coefficient of the cross peaks is a fit parameter or if it's set to zero
            if sum(C_pos(:,m),1) == 0
                Cstring = '0';
            else
                Cstring = ['C{' peakID '}'];
            end
            % The position along W1 is given by the diagonal peak
            XpeakGSB_w1 = ['P(' num2str(x0_pos(DiagPkXID(m))) ')'];
            
            % Check if the anharmonicity is the same as the diagonal peak or if it's a fit parameter
            XpeakGSB_w3_str = ['P(' num2str(x0_pos(DiagPkYID(m))) ')']; % GSB of the cross peak between A and B is at (x_A,y_B)
            XpeakESA_w3_str = [XpeakGSB_w3_str '-P(' num2str(y0_pos(DiagPkYID(m))) ')'];
            
            % Write the function string
            peakfnc{m} = ['G2Dc(X,Y,' XpeakGSB_w1 ','  XpeakGSB_w3_str ',P(' sxstr '),P(' systr '),' Cstring ',A{' peakGSB '}) + G2Dc(X,Y,' XpeakGSB_w1 ',' XpeakESA_w3_str ',P(' sxstr '),P(' systr '),' Cstring ',A{' peakESA '})'];
    end
end


%% BUILD THE FIT FUNCTION, STARTING PARAMETERS AND BOUNDS
% Build the fit function string
PeaksFunction     = str2func(['@(P,X,Y,C,A)' strjoin(peakfnc,' + ')]);

% Build the vector of starting parameters
Start_param     = zeros(tot_idx,1); 
UB              = zeros(tot_idx,1); % Upper bounds
LB              = zeros(tot_idx,1); % Lower bounds

%%% Diagonal peaks
% Time-independent parameters
Start_param(x0_pos(isDiagonal)) = X0_start(isDiagonal);
Start_param(y0_pos(isDiagonal)) = Y0_start(isDiagonal);
Start_param(Sx_pos(isDiagonal)) = SX_start(isDiagonal);
Start_param(Sy_pos(isDiagonal)) = SY_start(isDiagonal);

UB(x0_pos(isDiagonal)) = X0_start(isDiagonal)+10;
UB(y0_pos(isDiagonal)) = 50;
UB(Sx_pos(isDiagonal)) = 50;
UB(Sy_pos(isDiagonal)) = 50;

LB(x0_pos(isDiagonal)) = X0_start(isDiagonal)-10;
LB(y0_pos(isDiagonal)) = 5;
LB(Sx_pos(isDiagonal)) = 5;
LB(Sy_pos(isDiagonal)) = 5;

%%% Cross peaks
%%%%% PENDING: Explicit definition for intramolecular cross peaks

%%% Time-dependent parameters
% Spectral diffusion
Start_param(C_pos(C_pos~=0)) = 0.4;     % Starting C value of 0.5 for all points. Needs improvement.
UB(C_pos(C_pos~=0))     = 0.99;         % C can only be in the range [-1 1]. Considering 0 to 1 only
LB(C_pos(C_pos~=0))     = 0;            % C can only be in the range [-1 1]. Considering 0 to 1 only


% Amplitudes
% The data is normalized, so the min/max amplitudes should be around +- 5
    % Get the positions of each peak in terms of the W1 and W3 axes of the dataset
    pump_idx        = findClosestId2Val(PumpAxis,pump_pos)';
    probe_idx(:,1)  = findClosestId2Val(ProbeAxis,probe_pos(:,1));
    probe_idx(:,2)  = findClosestId2Val(ProbeAxis,probe_pos(:,2));

    % Evaluate the amplitudes of the input data at the position of each peak and use them as initial
    % parameters for the fit
    for m=1:Npeaks
        Start_param(GSBamp_pos(:,m))  = squeeze(ZData(pump_idx(m),probe_idx(m,1),:)); % GSB
        Start_param(ESAamp_pos(:,m))  = squeeze(ZData(pump_idx(m),probe_idx(m,2),:))'; % ESA
    end

UB(GSBamp_pos(:))       = 0;            % Bleaches can only be negative
UB(ESAamp_pos(:))       = +5;           % ESA can only be positive

LB(GSBamp_pos(:))       = -5;           % Bleaches can only be negative
LB(ESAamp_pos(:))       = 0;            % ESA can only be positive


%% SAVE the positions of the parameters to the ParamPos structure
ParamPos.Npeaks     = Npeaks;
ParamPos.Ndelays    = Ndelays;
ParamPos.x0_pos     = x0_pos;
ParamPos.y0_pos     = y0_pos;
ParamPos.Sx_pos     = Sx_pos;
ParamPos.Sy_pos     = Sy_pos;
ParamPos.GSBamp_pos = GSBamp_pos;
ParamPos.ESAamp_pos = ESAamp_pos;
ParamPos.isDiagonal = isDiagonal;
ParamPos.C_pos      = C_pos;
##### SOURCE END #####
--></body></html>